[**@strata-game-library/shaders**](../README.md)

***

[@strata-game-library/shaders](../globals.md) / terrainVertexShader

# Variable: terrainVertexShader

> `const` **terrainVertexShader**: "\n  uniform vec2 biomeCenters\[7\];\n  uniform float biomeRadii\[7\];\n  uniform int biomeTypes\[7\]; // 0=marsh, 1=forest, 2=desert, 3=tundra, 4=savanna, 5=mountain, 6=scrubland\n  \n  varying vec2 vUv;\n  varying vec3 vPos;\n  varying vec3 vWorldPos;\n  varying float vElevation;\n  varying float vSlope;\n  varying vec3 vNormal;\n  varying vec3 vTriplanarPos;\n  \n  // Simple hash noise\n  float hash(vec2 p) \{ \n    return fract(1e4 \* sin(17.0 \* p.x + p.y \* 0.1) \* (0.1 + abs(sin(p.y \* 13.0 + p.x)))); \n  \}\n  \n  float noise(vec2 p) \{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f \* f \* (3.0 - 2.0 \* f);\n    return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),\n               mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);\n  \}\n  \n  \n  int getBiomeType(vec2 pos, vec2 biomeCenters\[7\], int biomeTypes\[7\]) \{\n    int closestIdx = 0;\n    float closestDist = distance(pos, biomeCenters\[0\]);\n    \n    for (int i = 1; i \< 7; i++) \{\n      float dist = distance(pos, biomeCenters\[i\]);\n      if (dist \< closestDist) \{\n        closestDist = dist;\n        closestIdx = i;\n      \}\n    \}\n    \n    return biomeTypes\[closestIdx\];\n  \}\n\n  vec3 getBiomeColor(vec2 pos, vec2 biomeCenters\[7\], float biomeRadii\[7\], vec3 biomeColors\[7\]) \{\n    // Find closest biome\n    int closestIdx = 0;\n    float closestDist = distance(pos, biomeCenters\[0\]);\n    \n    for (int i = 1; i \< 7; i++) \{\n      float dist = distance(pos, biomeCenters\[i\]);\n      if (dist \< closestDist) \{\n        closestDist = dist;\n        closestIdx = i;\n      \}\n    \}\n    \n    vec3 baseColor = biomeColors\[closestIdx\];\n    \n    // Blend with adjacent biomes at boundaries\n    vec3 blendedColor = baseColor;\n    float totalWeight = 1.0;\n    \n    for (int i = 0; i \< 7; i++) \{\n      if (i != closestIdx) \{\n        float dist = distance(pos, biomeCenters\[i\]);\n        float blendRadius = biomeRadii\[i\] \* 0.3; // 30% blend zone\n        float weight = smoothstep(blendRadius, 0.0, dist - biomeRadii\[i\]);\n        blendedColor += biomeColors\[i\] \* weight;\n        totalWeight += weight;\n      \}\n    \}\n    \n    return blendedColor / totalWeight;\n  \}\n\n  \n  void main() \{\n    vUv = uv;\n    vPos = position;\n    \n    vec4 worldPos = modelMatrix \* vec4(position, 1.0);\n    vec2 worldXZ = worldPos.xz;\n    \n    // Calculate elevation based on biome\n    int biomeType = getBiomeType(worldXZ, biomeCenters, biomeTypes);\n    float elevation = 0.0;\n    \n    // Mountain biome: elevated terrain with slopes up to 45 degrees\n    if (biomeType == 5) \{\n      float n1 = noise(worldXZ \* 0.05);\n      float n2 = noise(worldXZ \* 0.1);\n      float n3 = noise(worldXZ \* 0.2);\n      elevation = n1 \* 15.0 + n2 \* 8.0 + n3 \* 3.0;\n    \}\n    // Tundra: gentle rolling hills\n    else if (biomeType == 3) \{\n      elevation = noise(worldXZ \* 0.03) \* 2.0;\n    \}\n    // Other biomes: mostly flat with subtle variation\n    else \{\n      elevation = noise(worldXZ \* 0.1) \* 0.5;\n    \}\n    \n    vec3 newPosition = position;\n    newPosition.y += elevation;\n    \n    vElevation = elevation;\n    vWorldPos = (modelMatrix \* vec4(newPosition, 1.0)).xyz;\n    \n    // Calculate approximate normal for triplanar mapping\n    float dx = noise(worldXZ + vec2(0.1, 0.0)) - noise(worldXZ - vec2(0.1, 0.0));\n    float dz = noise(worldXZ + vec2(0.0, 0.1)) - noise(worldXZ - vec2(0.0, 0.1));\n    float dy\_dx = dx \* 10.0;\n    float dy\_dz = dz \* 10.0;\n    vec3 tangentX = normalize(vec3(1.0, dy\_dx, 0.0));\n    vec3 tangentZ = normalize(vec3(0.0, dy\_dz, 1.0));\n    vNormal = normalize(cross(tangentZ, tangentX));\n    \n    // Calculate slope for walkability\n    vSlope = length(vec2(dx, dz)) \* 10.0;\n    \n    // Store world position for triplanar mapping\n    vTriplanarPos = vWorldPos;\n    \n    gl\_Position = projectionMatrix \* modelViewMatrix \* vec4(newPosition, 1.0);\n  \}\n"

Defined in: [terrain.ts:62](https://github.com/strata-game-library/shaders/blob/6bdfb2582aaf48f6f3744bdf896e8c5144c8f6df/src/terrain.ts#L62)
